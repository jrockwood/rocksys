;
; kernel.rasm (Rockwood OS Kernel)
; --------------------------------
; Copyright (c) 2017 Justin Rockwood. All rights reserved.
;
; We're starting a pattern of leaving gaps between functions in case we need to
; extend them in the future. This ensures that we don't have to change memory
; addresses if we change the code. The 'times' command will do that for us, but
; we don't have an assembler yet, so we have to do it manually by filling in
; zeros.
;

; [BITS 16]               ; Tells the assembler to generate 16 bit code

; start:
~e9 ~fd ~00 ; jmp near kernel_main  ; keep to 3 bytes

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; System Calls Lookup
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; sys_call_table:
; This table contains a lookup of all of the system calls that we expose.
~e9 ~9a ~01 ; jmp os_print_string               ; 0x03
~e9 ~b7 ~01 ; jmp os_print_line                 ; 0x06
~e9 ~d4 ~01 ; jmp os_print_newline              ; 0x09
~e9 ~f1 ~01 ; jmp os_print_char                 ; 0x0c


; times 0x60 - ($ - $$) db 0

                                                              ~00
~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00   ~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00

~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00   ~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00
~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00   ~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00
~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00   ~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00
~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00   ~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Data Section
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; 0x60
; data_start:
; str_hello:
;     db `Hello, world!`, 0
~48 ~65 ~6c ~6c ~6f ~2c ~20 ~77   ~6f ~72 ~6c ~64 ~21 ~00

; End the data section at the 256th byte (0x100)
; times 0x100 - ($ - $$) db 0

                                                          ~00 ~00
~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00   ~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00

~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00   ~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00
~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00   ~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00
~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00   ~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00
~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00   ~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00

~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00   ~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00
~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00   ~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00
~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00   ~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00
~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00   ~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00

; 0x100
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Program
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; kernel_main:
    ; --------------------------------------------------------------------------
    ; The bootloader loads us at address 0x2000:0000, so set up the segment
    ; registers to all point to the same segment.

~fa         ; cli                 ; disable interrupts
~8c ~c8     ; mov ax, cs
~8e ~d8     ; mov ds, ax
~8e ~c0     ; mov es, ax
~8e ~e0     ; mov fs, ax
~8e ~e8     ; mov gs, ax

    ; --------------------------------------------------------------------------
    ; Create the stack at 0x2000:FFFF. It will move down in memory addresses.

~b8 ~00 ~20 ; mov ax, 0x2000
~8e ~d0     ; mov ss, ax
~bc ~ff ~ff ; mov sp, 0xffff
~fb         ; sti                 ; restore interrupts

    ; --------------------------------------------------------------------------
    ; Print hello world

~68 ~60 ~00 ; push str_hello
~b8 ~06 ~00 ; mov ax, os_print_line
~ff ~d0     ; call ax
~83 ~c4 ~02 ; add sp, 2

    ; --------------------------------------------------------------------------
    ; We're done

~fa         ; cli
~f4         ; hlt

; ------------------------------------------------------------------------------

; Start the system calls at 0x01a0.
; times 0x01a0 - ($ - $$) db 0

    ~00 ~00 ~00 ~00 ~00 ~00 ~00   ~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00
~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00   ~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00
~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00   ~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00
~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00   ~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00

~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00   ~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00
~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00   ~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00
~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00   ~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00
~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00   ~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; System Calls
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; 0x1a0
; ------------------------------------------------------------------------------
; os_print_string(str)
;   Prints a string to the console.
;
;   Input
;     str - null terminated string to print
;
;   Returns
;     Nothing
; ------------------------------------------------------------------------------

; os_print_string:
~55         ; push bp
~89 ~e5     ; mov bp, sp
~60         ; pusha
~8b ~76 ~04 ; mov si, [bp + 4]    ; SI = str
~b4 ~0e     ; mov ah, 0x0e        ; INT 10h, AH=0Eh: write text in teletype mode
~31 ~db     ; xor bx, bx          ; BH = 0 page number (text modes) and
            ;                     ; BL = 0 foreground color (graphics modes only)
; .nextChar:
~ac         ; lodsb               ; loads the byte at DS:SI to AL and increment SI
~08 ~c0     ; or al, al           ; see if we've read the null termination
~74 ~04     ; jz .exit
~cd ~10     ; int 0x10            ; print the character
~eb ~f7     ; jmp .nextChar
; .exit:
~61         ; popa
~89 ~ec     ; mov sp, bp
~5d         ; pop bp
~c3         ; ret

; times 0x01c0 - ($ - $$) db 0

                                      ~00 ~00 ~00 ~00 ~00 ~00 ~00

; 0x1c0
; ------------------------------------------------------------------------------
; os_print_line(str)
;   Prints a string to the console, followed by a CR/LF combination.
;
;   Input
;     str - null terminated string to print
;
;   Returns
;     Nothing
; ------------------------------------------------------------------------------

; os_print_line:
~55         ; push bp
~89 ~e5     ; mov bp, sp
~ff ~76 ~04 ; push word [bp + 4]
~b8 ~03 ~00 ; mov ax, os_print_string
~ff ~d0     ; call ax
~83 ~c4 ~02 ; add sp, 2
~b8 ~09 ~00 ; mov ax, os_print_newline
~ff ~d0     ; call ax
~89 ~ec     ; mov sp, bp
~5d         ; pop bp
~c3         ; ret

; times 0x1e0 - ($ - $$) db 0
                            ~00   ~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00

; 0x1e0
; ------------------------------------------------------------------------------
; os_print_newline()
;   Prints a CR/LF combination.
;
;   Input
;     Nothing
;   Returns
;     Nothing
; ------------------------------------------------------------------------------

; os_print_newline:
~6a ~0d     ; push `\r`
~b8 ~0c ~00 ; mov ax, os_print_char
~ff ~d0     ; call ax
~83 ~c4 ~02 ; add sp, 2
~6a ~0a     ; push `\n`
~b8 ~0c ~00 ; mov ax, os_print_char
~ff ~d0     ; call ax
~83 ~c4 ~02 ; add sp, 2
~c3         ; ret

; times 0x200 - ($ - $$) db 0
                    ~00 ~00 ~00   ~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00

; 0x200
; ------------------------------------------------------------------------------
; os_print_char(char)
;   Prints a character to the console.
;
;   Input
;     char - character to print
;
;   Returns
;     Nothing
; ------------------------------------------------------------------------------

; os_print_char:
~55         ; push bp
~89 ~e5     ; mov bp, sp
~60         ; pusha
~b4 ~0e     ; mov ah, 0x0e        ; INT 10h, AH=0Eh: write text in teletype mode
~31 ~db     ; xor bx, bx          ; BH = 0 page number (text modes) and
            ;                     ; BL = 0 foreground color (graphics modes only)
~8a ~46 ~04 ; mov al, [bp + 4]
~cd ~10     ; int 0x10            ; print the character
~61         ; popa
~89 ~ec     ; mov sp, bp
~5d         ; pop bp
~c3         ; ret

        ~00 ~00 ~00 ~00 ~00 ~00   ~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00

; 0x210
